// Static JSON generated by GitHub Actions
const API_BASE = "data/prices.json";

const FALLBACK_META = {
  os:   [{ value: "Linux" }, { value: "Windows" }],
  vcpu: [1, 2, 4, 8, 16],
  ram:  [1, 2, 4, 8, 16, 32]
};

document.addEventListener("DOMContentLoaded", async () => {
  try {
    // Load meta from prices.json (if Actions ran) else use fallback
    const r = await fetch(API_BASE, { mode: "cors" });
    const j = r.ok ? await r.json() : { meta: FALLBACK_META };
    const meta = j.meta || FALLBACK_META;

    // Support both array-of-values or array-of-{value} for meta.os
    const osItems = Array.isArray(meta.os)
      ? meta.os.map(x => (typeof x === "string" ? { value: x, text: x } : { value: x.value, text: x.value }))
      : FALLBACK_META.os.map(x => ({ value: x.value, text: x.value }));

    fillSelect("os",  osItems);
    fillSelect("cpu", (meta.vcpu || FALLBACK_META.vcpu).map(v => ({ value: v, text: v })));
    fillSelect("ram", (meta.ram  || FALLBACK_META.ram ).map(v => ({ value: v, text: v })));
  } catch {
    fillSelect("os",   FALLBACK_META.os.map(x => ({ value: x.value, text: x.value })));
    fillSelect("cpu",  FALLBACK_META.vcpu.map(v => ({ value: v, text: v })));
    fillSelect("ram",  FALLBACK_META.ram.map(v => ({ value: v, text: v })));
  }
  setSelectValue("os", "Linux");
  setSelectValue("cpu", "2");
  setSelectValue("ram", "4");
});

// ---------- UI helpers ----------
function fillSelect(id, items) {
  const el = document.getElementById(id);
  el.innerHTML = "";
  for (const it of items) {
    const opt = document.createElement("option");
    opt.value = it.value;
    opt.textContent = it.text;
    el.appendChild(opt);
  }
}
function setSelectValue(id, value) {
  const el = document.getElementById(id);
  const match = Array.from(el.options).find(o => o.value == value);
  if (match) el.value = value;
}
function fmt(n)      { return (n == null || isNaN(n)) ? "-" : `$${Number(n).toFixed(4)}`; }
function monthly(ph) { return (ph == null || isNaN(ph)) ? null : ph * 730; }

function setStatus(msg, level="info") {
  const el = document.getElementById("status");
  el.textContent = msg;
  el.style.color = (level === "error") ? "var(--err)" :
                   (level === "warn")  ? "var(--warn)" : "var(--muted)";
}

// ---------- Compare using local prices.json ----------
async function compare() {
  const btn = document.getElementById("compareBtn");
  btn.disabled = true;
  setStatus("Fetching local prices…");

  const os   = document.getElementById("os").value;
  const vcpu = Number(document.getElementById("cpu").value);
  const ram  = Number(document.getElementById("ram").value);

  try {
    resetCards();

    const r = await fetch(API_BASE, { mode: "cors" });
    if (!r.ok) throw new Error(`Failed to read ${API_BASE}`);
    const data = await r.json();

    // --------- AWS selection ----------
    let awsCard;
    try {
      const a = findBestAws(data.aws || [], vcpu, ram, os);
      awsCard = a ? {
        instance: a.instance,
        vcpu: a.vcpu,
        ram: a.ram,
        pricePerHourUSD: a.pricePerHourUSD,
        region: a.region
      } : null;
    } catch (e) {
      awsCard = { error: e.message || String(e) };
    }

    // --------- Azure selection ----------
    let azCard;
    try {
      const z = findBestAzure(data.azure || [], vcpu, ram, os);
      azCard = z ? {
        instance: z.instance,
        vcpu: z.vcpu ?? vcpu,
        ram: z.ram  ?? ram,
        pricePerHourUSD: z.pricePerHourUSD,
        region: z.region
      } : null;
    } catch (e) {
      azCard = { error: e.message || String(e) };
    }

    // ---------- Render AWS ----------
    if (!awsCard || awsCard.error) {
      document.getElementById("awsInstance").innerText = `Error: ${awsCard?.error || "No match"}`;
    } else {
      document.getElementById("awsInstance").innerText = `Instance: ${awsCard.instance} (${awsCard.region})`;
      document.getElementById("awsCpu").innerText      = `vCPU: ${awsCard.vcpu}`;
      document.getElementById("awsRam").innerText      = `RAM: ${awsCard.ram} GB`;
      document.getElementById("awsPrice").innerText    = `Price/hr: ${fmt(awsCard.pricePerHourUSD)}`;
      document.getElementById("awsMonthly").innerText  = `≈ Monthly: ${fmt(monthly(awsCard.pricePerHourUSD))}`;
    }

    // ---------- Render Azure ----------
    if (!azCard || azCard.error) {
      document.getElementById("azInstance").innerText = `Error: ${azCard?.error || "No match"}`;
    } else {
      document.getElementById("azInstance").innerText = `VM Size: ${azCard.instance} (${azCard.region})`;
      document.getElementById("azCpu").innerText      = `vCPU: ${azCard.vcpu}`;
      document.getElementById("azRam").innerText      = `RAM: ${azCard.ram} GB`;
      document.getElementById("azPrice").innerText    = `Price/hr: ${fmt(azCard.pricePerHourUSD)}`;
      document.getElementById("azMonthly").innerText  = `≈ Monthly: ${fmt(monthly(azCard.pricePerHourUSD))}`;
    }

    setStatus("Comparison complete ✓");
  } catch (err) {
    console.error(err);
    setStatus(`Error: ${err.message}`, "error");
    alert("Unable to read local prices. Please try again.");
  } finally {
    btn.disabled = false;
  }
}

function resetCards() {
  document.getElementById("awsInstance").innerText = "Instance: …";
  document.getElementById("awsCpu").innerText      = "vCPU: …";
  document.getElementById("awsRam").innerText      = "RAM: …";
  document.getElementById("awsPrice").innerText    = "Price/hr: -";
  document.getElementById("awsMonthly").innerText  = "≈ Monthly: -";

  document.getElementById("azInstance").innerText  = "VM Size: …";
  document.getElementById("azCpu").innerText       = "vCPU: …";
  document.getElementById("azRam").innerText       = "RAM: …";
  document.getElementById("azPrice").innerText     = "Price/hr: -";
  document.getElementById("azMonthly").innerText   = "≈ Monthly: -";
}

// ---------- Local matching logic ----------

// Pick the AWS instance with minimal distance to requested vCPU/RAM.
// Prices.json (AWS) has vcpu/ram/pricePerHourUSD populated from Bulk Offer files.
function findBestAws(list, vcpu, ram, os) {
  if (!Array.isArray(list) || list.length === 0) throw new Error("AWS price list is empty");

  // Optional: prefer Linux or Windows pricing if you later split by OS in prices.json.
  const filtered = list.filter(x => isFinite(x.vcpu) && isFinite(x.ram) && isFinite(x.pricePerHourUSD));
  if (filtered.length === 0) throw new Error("No AWS entries with vCPU/RAM/price");

  // Score by distance; break ties by lower price.
  let best = null;
  let bestScore = Infinity;
  for (const x of filtered) {
    const score = distance(x.vcpu, vcpu) + distance(x.ram, ram);
    const tieBreaker = x.pricePerHourUSD || Infinity;
    if (score < bestScore || (score === bestScore && tieBreaker < (best?.pricePerHourUSD ?? Infinity))) {
      best = x;
      bestScore = score;
    }
  }
  return best;
}

// For Azure retail rows, vCPU/RAM may be missing. We attempt to infer from SKU text.
// If still missing, we score by price only, then by name similarity.
function findBestAzure(list, vcpu, ram, os) {
  if (!Array.isArray(list) || list.length === 0) throw new Error("Azure price list is empty");

  // Enrich with heuristics
  const enriched = list.map(x => {
    const meta = inferAzureCoresRamFromName(x.instance);
    return {
      ...x,
      vcpu: x.vcpu ?? meta.vcpu,
      ram:  x.ram  ?? meta.ram
    };
  });

  // Score with fallbacks
  let best = null;
  let bestScore = Infinity;
  for (const x of enriched) {
    // If we have cores/ram, use distance; else use price heuristic
    let score;
    if (isFinite(x.vcpu) && isFinite(x.ram)) {
      score = distance(x.vcpu, vcpu) + distance(x.ram, ram);
    } else {
      // Penalize unknown specs but allow low price to win
      const price = Number(x.pricePerHourUSD) || Infinity;
      score = 500 + price; // large constant so known-spec SKUs preferred
    }

    // Tie-breaker: cheaper first
    const tieBreaker = Number(x.pricePerHourUSD) || Infinity;
    if (score < bestScore || (score === bestScore && tieBreaker < (best?.pricePerHourUSD ?? Infinity))) {
      best = x;
      bestScore = score;
    }
  }
  return best;
}

function distance(a, b) {
  if (!isFinite(a) || !isFinite(b)) return 1000;
  return Math.abs(Number(a) - Number(b));
}

// Try to parse cores/RAM from common Azure SKU patterns (e.g., "Standard_D4s_v3", "D8as v5").
// This is best-effort; you can refine later with a SKU map.
function inferAzureCoresRamFromName(name) {
  if (!name || typeof name !== "string") return { vcpu: null, ram: null };
  const n = name.toLowerCase();

  // Extract number (like D4s, F8s, E2, B2ms → 4,8,2,2 cores approx.)
  const coreMatch = n.match(/(?:^standard_)?[a-z]+(\d+)[a-z]*\s*(v\d+)?/i);
  const vcpu = coreMatch ? Number(coreMatch[1]) : null;

  // Rough family RAM per core defaults (very rough fallback if no explicit number in name)
  // D-series ~ 4 GB/core, F-series ~ 2 GB/core, E-series ~ 8 GB/core, B-series ~ ~4 GB/core
  let familyRamPerCore = null;
  if (n.startsWith("standard_d")) familyRamPerCore = 4;
  else if (n.startsWith("standard_f")) familyRamPerCore = 2;
  else if (n.startsWith("standard_e")) familyRamPerCore = 8;
  else if (n.startsWith("standard_b")) familyRamPerCore = 4;

  const ram = (vcpu && familyRamPerCore) ? vcpu * familyRamPerCore : null;
  return { vcpu, ram };
}
