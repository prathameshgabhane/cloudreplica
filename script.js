// ============================================================
// Static JSON generated by GitHub Actions (compute + storage)
const API_BASE = "data/prices.json";

// ---------- Defaults for dropdown meta ----------
const FALLBACK_META = {
  os:   [{ value: "Linux" }, { value: "Windows" }],
  vcpu: [1, 2, 4, 8, 16],
  ram:  [1, 2, 4, 8, 16, 32]
};

const HRS_PER_MONTH = 730;

// --- in-memory storage pricing ---
let STORAGE_CFG = {
  aws:  { region: "us-east-1", ssd_per_gb_month: 0.08, hdd_st1_per_gb_month: 0.045 },
  azure: {
    region: "eastus",
    ssd_monthly: {4:0.3,8:0.6,16:1.2,32:2.4,64:4.8,128:9.6,256:19.2,512:38.4},
    hdd_monthly: {32:1.536,64:3.008,128:5.888,256:11.328}
  }
};

// ============================================================
// Bootstrapping
document.addEventListener("DOMContentLoaded", async () => {
  fillSelect("os",   [{ value: "Linux", text: "Linux" }, { value: "Windows", text: "Windows" }]);
  fillSelect("cpu",  [1, 2, 4, 8, 16].map(v => ({ value: v, text: v })));
  fillSelect("ram",  [1, 2, 4, 8, 16, 32].map(v => ({ value: v, text: v })));

  setSelectValue("os", "Linux");
  setSelectValue("cpu", "2");
  setSelectValue("ram", "4");

  ["awsFamily", "azFamily"].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener("change", () => compare(false));
  });

  initStorageTypeTooltip();
  initOsTypeTooltip();

  // Try to pull meta & storage data from prices.json
  try {
    const r = await fetch(API_BASE, { mode: "cors" });
    const j = r.ok ? await r.json() : {};
    const meta = j.meta;

    if (j.storage?.aws || j.storage?.azure) {
      STORAGE_CFG = {
        aws: {
          region: j.storage?.aws?.region ?? STORAGE_CFG.aws.region,
          ssd_per_gb_month: Number(j.storage?.aws?.ssd_per_gb_month ?? STORAGE_CFG.aws.ssd_per_gb_month),
          hdd_st1_per_gb_month: Number(j.storage?.aws?.hdd_st1_per_gb_month ?? STORAGE_CFG.aws.hdd_st1_per_gb_month),
        },
        azure: {
          region: j.storage?.azure?.region ?? STORAGE_CFG.azure.region,
          ssd_monthly: j.storage?.azure?.ssd_monthly ?? STORAGE_CFG.azure.ssd_monthly,
          hdd_monthly: j.storage?.azure?.hdd_monthly ?? STORAGE_CFG.azure.hdd_monthly,
        }
      };
    }

    if (meta) {
      const osItems = Array.isArray(meta.os)
        ? meta.os.map(x => (typeof x === "string" ? { value: x, text: x } : { value: x.value, text: x.value }))
        : [{ value: "Linux", text: "Linux" }, { value: "Windows", text: "Windows" }];
      fillSelect("os", osItems);
      fillSelect("cpu", (meta.vcpu || FALLBACK_META.vcpu).map(v => ({ value: v, text: v })));
      fillSelect("ram", (meta.ram  || FALLBACK_META.ram).map(v => ({ value: v, text: v })));

      setSelectValue("os", "Linux");
      setSelectValue("cpu", "2");
      setSelectValue("ram", "4");
    }
  } catch {}

  compare(false);
});

// ============================================================
// Helpers
function fillSelect(id, items) {
  const el = document.getElementById(id);
  if (!el) return;
  el.innerHTML = "";
  for (const it of items) {
    const opt = document.createElement("option");
    opt.value = it.value;
    opt.textContent = it.text;
    el.appendChild(opt);
  }
}

function setSelectValue(id, value) {
  const el = document.getElementById(id);
  if (!el) return;
  const match = Array.from(el.options).find(o => o.value == value);
  if (match) el.value = value;
}

function fmt(n)      { return (n == null || isNaN(n)) ? "—" : `$${Number(n).toFixed(4)}`; }
function monthly(ph) { return (ph == null || isNaN(ph)) ? null : ph * HRS_PER_MONTH; }

function setStatus(msg, level="info") {
  const el = document.getElementById("status");
  if (!el) return;
  const err  = "var(--err,#b91c1c)";
  const warn = "var(--warn,#b45309)";
  const mut  = "var(--muted,#666)";
  el.textContent = msg;
  el.style.color = (level === "error") ? err :
                   (level === "warn")  ? warn : mut;
}

function safeSetText(id, text) {
  const el = document.getElementById(id);
  if (el) el.textContent = text;
}

function appendToText(id, extra) {
  const el = document.getElementById(id);
  if (el) el.textContent = (el.textContent || "") + extra;
}

function sumSafe(a, b) {
  const na = (a == null || isNaN(a)) ? 0 : Number(a);
  const nb = (b == null || isNaN(b)) ? 0 : Number(b);
  if (a == null && b == null) return null;
  return na + nb;
}

// ============================================================
// OS normalization
function normalizeOs(val) {
  const s = String(val || '').toLowerCase();
  if (s.startsWith('win')) return 'windows';
  return 'linux';
}

// Azure retail has no special tenancy/billing markers — always return true
function isOnDemandSharedAzure() {
  return true;
}

// AWS check
function isOnDemandSharedAws(x) {
  const blob = [x.productName, x.skuName, x.meterName, x.instance]
    .filter(Boolean).join(" ").toLowerCase();
  if (blob.includes("reserved") || blob.includes("savings plan") || blob.includes("spot")) return false;
  return true;
}

// ============================================================
// Family helpers
function showFamilyFilters() {
  document.getElementById("awsFamilyWrap").style.display = "flex";
  document.getElementById("azFamilyWrap").style.display  = "flex";
}

function isAwsInFamily(inst, family) {
  if (!family) return true;
  const s = String(inst || "").toLowerCase();
  if (family === "general")  return /^[mt]/.test(s);
  if (family === "compute")  return /^c/.test(s);
  if (family === "memory")   return /^[rxz]/.test(s);
  return true;
}

function isAzureInFamily(inst, family) {
  if (!family) return true;
  const n = String(inst || "").toLowerCase();
  const m = n.match(/standard_([a-z]+)/);
  const first = m?.[1]?.[0] || n[0] || null;
  if (!first) return true;
  if (family === "general")  return first === "d" || first === "b";
  if (family === "compute")  return first === "f";
  if (family === "memory")   return first === "e" || first === "m";
  return true;
}

// ============================================================
// Compare
async function compare(resetFamilies = false) {
  const btn = document.getElementById("compareBtn");
  if (btn) btn.disabled = true;
  setStatus("Fetching local prices…");

  if (resetFamilies) {
    document.getElementById("awsFamily").value = "";
    document.getElementById("azFamily").value  = "";
  }

  const os           = document.getElementById("os")?.value || "Linux";
  const vcpu         = Number(document.getElementById("cpu")?.value ?? 0);
  const ram          = Number(document.getElementById("ram")?.value ?? 0);
  const storageType  = (document.getElementById("storageType")?.value || "hdd").toLowerCase();
  const storageAmtGB = Number(document.getElementById("storageAmt")?.value ?? 0);

  const familyAws = document.getElementById("awsFamily")?.value || "";
  const familyAz  = document.getElementById("azFamily")?.value  || "";

  try {
    resetCards();

    const r = await fetch(API_BASE, { mode: "cors" });
    if (!r.ok) throw new Error(`Failed to read ${API_BASE}`);
    const data = await r.json();

    // Merge storage cfg
    if (data.storage?.aws || data.storage?.azure) {
      STORAGE_CFG = {
        aws: {
          region: data.storage?.aws?.region ?? STORAGE_CFG.aws.region,
          ssd_per_gb_month: Number(data.storage?.aws?.ssd_per_gb_month ?? STORAGE_CFG.aws.ssd_per_gb_month),
          hdd_st1_per_gb_month: Number(data.storage?.aws?.hdd_st1_per_gb_month ?? STORAGE_CFG.aws.hdd_st1_per_gb_month),
        },
        azure: {
          region: data.storage?.azure?.region ?? STORAGE_CFG.azure.region,
          ssd_monthly: data.storage?.azure?.ssd_monthly ?? STORAGE_CFG.azure.ssd_monthly,
          hdd_monthly: data.storage?.azure?.hdd_monthly ?? STORAGE_CFG.azure.hdd_monthly,
        }
      };
    }

    // AWS match
    let awsCard;
    try {
      const a = findBestAws(data.aws || [], vcpu, ram, os, familyAws);
      awsCard = a ? {
        instance: a.instance,
        vcpu: a.vcpu,
        ram: a.ram,
        pricePerHourUSD: a.pricePerHourUSD,
        region: a.region
      } : null;
    } catch (e) {
      awsCard = { error: e.message };
    }

    // Azure match
    let azCard;
    try {
      const z = findBestAzure(data.azure || [], vcpu, ram, os, familyAz);
      azCard = z ? {
        instance: z.instance,
        vcpu: z.vcpu,
        ram: z.ram,
        pricePerHourUSD: z.pricePerHourUSD,
        region: z.region
      } : null;
    } catch (e) {
      azCard = { error: e.message };
    }

    // Storage labels
    safeSetText("awsStorageSel", `Storage: ${storageAmtGB} GB ${storageType.toUpperCase()}`);
    safeSetText("azStorageSel",  `Storage: ${storageAmtGB} GB ${storageType.toUpperCase()}`);

    // AWS storage
    const awsStorageMonthly = getAwsStorageMonthlyFromCfg(storageType, storageAmtGB, STORAGE_CFG.aws);
    const awsStorageHr = awsStorageMonthly != null ? awsStorageMonthly / HRS_PER_MONTH : null;

    // Azure storage
    const { sku: azSku, size: azGB, monthlyUSD: azStorageMonthly } =
      getAzureStorageSkuAndMonthlyFromCfg(storageType, storageAmtGB, STORAGE_CFG.azure);
    const azStorageHr = azStorageMonthly != null ? azStorageMonthly / HRS_PER_MONTH : null;

    // Render AWS
    if (!awsCard || awsCard.error) {
      safeSetText("awsInstance", `Recommended Instance: Error: ${awsCard?.error ?? "No match"}`);
    } else {
      safeSetText("awsInstance", `Recommended Instance: ${awsCard.instance} (${awsCard.region})`);
      safeSetText("awsCpu",     `vCPU: ${awsCard.vcpu}`);
      safeSetText("awsRam",     `RAM: ${awsCard.ram} GB`);
      safeSetText("awsPrice",   `Price/hr: ${fmt(awsCard.pricePerHourUSD)}`);
      safeSetText("awsMonthly", `≈ Monthly: ${fmt(monthly(awsCard.pricePerHourUSD))}`);
    }

    // Render Azure
    if (!azCard || azCard.error) {
      safeSetText("azInstance", `Recommended VM Size: Error: ${azCard?.error ?? "No match"}`);
    } else {
      safeSetText("azInstance", `Recommended VM Size: ${azCard.instance} (${azCard.region})`);
      safeSetText("azCpu",     `vCPU: ${azCard.vcpu}`);
      safeSetText("azRam",     `RAM: ${azCard.ram} GB`);
      safeSetText("azPrice",   `Price/hr: ${fmt(azCard.pricePerHourUSD)}`);
      safeSetText("azMonthly", `≈ Monthly: ${fmt(monthly(azCard.pricePerHourUSD))}`);
    }

    // Storage rendering
    safeSetText("awsStoragePriceHr", fmt(awsStorageHr));
    safeSetText("awsStorageMonthly", fmt(awsStorageMonthly));
    safeSetText("azStoragePriceHr",  fmt(azStorageHr));
    safeSetText("azStorageMonthly",  fmt(azStorageMonthly));

    if (azSku) {
      const extra = (azGB && azGB !== storageAmtGB)
        ? ` (billed as ${azGB} GB ${storageType.toUpperCase()}, ${azSku})`
        : ` (${azSku})`;
      appendToText("azStorageSel", extra);
    }

    // Totals
    const awsComputeHr     = awsCard?.pricePerHourUSD ?? null;
    const awsComputeMonth  = monthly(awsComputeHr);
    const awsTotalHr       = sumSafe(awsComputeHr, awsStorageHr);
    const awsTotalMonthly  = sumSafe(awsComputeMonth, awsStorageMonthly);

    const azComputeHr     = azCard?.pricePerHourUSD ?? null;
    const azComputeMonth  = monthly(azComputeHr);
    const azTotalHr       = sumSafe(azComputeHr, azStorageHr);
    const azTotalMonthly  = sumSafe(azComputeMonth, azStorageMonthly);

    safeSetText("awsTotalHr",      fmt(awsTotalHr));
    safeSetText("awsTotalMonthly", fmt(awsTotalMonthly));
    safeSetText("azTotalHr",      fmt(azTotalHr));
    safeSetText("azTotalMonthly", fmt(azTotalMonthly));

    showFamilyFilters();
    setStatus("Comparison complete ✓");
  } catch (err) {
    console.error(err);
    setStatus(`Error: ${err.message}`, "error");
    alert("Unable to read local prices. Please try again.");
  } finally {
    if (btn) btn.disabled = false;
  }
}

// ============================================================
// Storage Sku mappers

function getAwsStorageMonthlyFromCfg(type, gb, awsCfg) {
  if (!isFinite(gb) || gb <= 0) return null;
  const t = (type || "hdd").toLowerCase();
  if (t === "ssd") return gb * Number(awsCfg?.ssd_per_gb_month ?? 0.08);
  return gb * Number(awsCfg?.hdd_st1_per_gb_month ?? 0.045);
}

function getAzureStorageSkuAndMonthlyFromCfg(type, gb, azCfg) {
  const t = (type || "hdd").toLowerCase();
  if (!isFinite(gb) || gb <= 0) return { sku: null, size: null, monthlyUSD: null };

  const ssdTbl = azCfg?.ssd_monthly || {};
  const hddTbl = azCfg?.hdd_monthly || {};

  if (t === "ssd") {
    const size = nearestCeil(gb, Object.keys(ssdTbl).map(Number));
    return { 
      sku: sizeToAzureSku("ssd", size),
      size,
      monthlyUSD: size != null ? (ssdTbl[size] ?? null) : null
    };
  } else {
    const size = nearestCeil(gb, Object.keys(hddTbl).map(Number));
    return { 
      sku: sizeToAzureSku("hdd", size),
      size,
      monthlyUSD: size != null ? (hddTbl[size] ?? null) : null
    };
  }
}

function nearestCeil(requested, allowed) {
  const sorted = [...allowed].sort((a, b) => a - b);
  for (const s of sorted) if (requested <= s) return s;
  return sorted.length ? sorted[sorted.length - 1] : null;
}

function sizeToAzureSku(type, size) {
  if (!isFinite(size)) return null;

  if (type === "ssd") {
    const map = {
      4:"E1", 8:"E2", 16:"E3", 32:"E4", 64:"E6",
      128:"E10", 256:"E15", 512:"E20",
      1024:"E30", 2048:"E40", 4096:"E50"
    };
    return map[size] || null;
  } else {
    const map = {
      32:"S4", 64:"S6", 128:"S10", 256:"S15", 512:"S20",
      1024:"S30", 2048:"S40", 4096:"S50"
    };
    return map[size] || null;
  }
}

// ============================================================
// Reset cards
function resetCards() {
  safeSetText("awsInstance", `Recommended Instance: …`);
  safeSetText("azInstance",  `Recommended VM Size: …`);

  safeSetText("awsCpu",      "vCPU: …");
  safeSetText("awsRam",      "RAM: …");
  safeSetText("awsPrice",    "Price/hr: -");
  safeSetText("awsMonthly",  "≈ Monthly: -");

  safeSetText("azCpu",       "vCPU: …");
  safeSetText("azRam",       "RAM: …");
  safeSetText("azPrice",     "Price/hr: -");
  safeSetText("azMonthly",   "≈ Monthly: -");

  safeSetText("awsStorageSel",      "Storage: —");
  safeSetText("awsStoragePriceHr",  "—");
  safeSetText("awsStorageMonthly",  "—");
  safeSetText("awsTotalHr",         "—");
  safeSetText("awsTotalMonthly",    "—");

  safeSetText("azStorageSel",       "Storage: —");
  safeSetText("azStoragePriceHr",   "—");
  safeSetText("azStorageMonthly",   "—");
  safeSetText("azTotalHr",          "—");
  safeSetText("azTotalMonthly",     "—");
}

// ============================================================
// Matching Algorithms

function findBestAws(list, vcpu, ram, os, family) {
  if (!Array.isArray(list) || list.length === 0)
    throw new Error("AWS price list is empty");

  const wantOS = normalizeOs(os);

  const filtered = list.filter(x =>
    isOnDemandSharedAws(x) &&
    (!wantOS || normalizeOs(x.os) === wantOS) &&
    isFinite(x.vcpu) &&
    isFinite(x.ram) &&
    isFinite(x.pricePerHourUSD) &&
    isAwsInFamily(x.instance, family)
  );

  if (filtered.length === 0)
    throw new Error(`No AWS entries for OS=${os} family=${family || "any"}`);

  let best = null;
  let bestScore = Infinity;

  for (const x of filtered) {
    const score = distance(x.vcpu, vcpu) + distance(x.ram, ram);
    if (score < bestScore || (score === bestScore && x.pricePerHourUSD < (best?.pricePerHourUSD ?? Infinity))) {
      best = x;
      bestScore = score;
    }
  }
  return best;
}

function findBestAzure(list, vcpu, ram, os, family) {
  if (!Array.isArray(list) || list.length === 0)
    throw new Error("Azure price list is empty");

  const wantOS = normalizeOs(os);

  let pre = list.filter(x =>
    isOnDemandSharedAzure() &&
    (!wantOS || normalizeOs(x.os) === wantOS) &&
    isAzureInFamily(x.instance, family)
  );

  if (pre.length === 0) {
    pre = list.filter(x => isAzureInFamily(x.instance, family));
  }

  if (pre.length === 0)
    throw new Error(`No Azure entries for OS=${os} family=${family || "any"}`);

  // specs already included in prices.json
  const enriched = pre;

  let best = null;
  let bestScore = Infinity;

  for (const x of enriched) {
    const score = (isFinite(x.vcpu) && isFinite(x.ram))
      ? distance(x.vcpu, vcpu) + distance(x.ram, ram)
      : 9999;

    if (score < bestScore || (score === bestScore && x.pricePerHourUSD < (best?.pricePerHourUSD ?? Infinity))) {
      best = x;
      bestScore = score;
    }
  }

  return best;
}

function distance(a, b) {
  if (!isFinite(a) || !isFinite(b)) return 1000;
  return Math.abs(Number(a) - Number(b));
}
