// ============================================================
// Static JSON generated by GitHub Actions (compute + storage)
const API_BASE = "data/prices.json";

// ---------- Defaults for dropdown meta ----------
const FALLBACK_META = {
  os:   [{ value: "Linux" }, { value: "Windows" }],
  vcpu: [1, 2, 4, 8, 16],
  ram:  [1, 2, 4, 8, 16, 32]
};

const HRS_PER_MONTH = 730;

// --- in-memory storage pricing ---
let STORAGE_CFG = {
  aws:  { region: "us-east-1", ssd_per_gb_month: 0.08, hdd_st1_per_gb_month: 0.045 },
  azure:{ region: "eastus",
          ssd_monthly: {4:0.3,8:0.6,16:1.2,32:2.4,64:4.8,128:9.6,256:19.2,512:38.4},
          hdd_monthly: {32:1.536,64:3.008,128:5.888,256:11.328} }
};

// ============================================================
// Bootstrapping
document.addEventListener("DOMContentLoaded", async () => {
  // Fallback meta so UI isn't blank
  fillSelect("os",   [{ value: "Linux", text: "Linux" }, { value: "Windows", text: "Windows" }]);
  fillSelect("cpu",  [1, 2, 4, 8, 16].map(v => ({ value: v, text: v })));
  fillSelect("ram",  [1, 2, 4, 8, 16, 32].map(v => ({ value: v, text: v })));
  setSelectValue("os", "Linux");
  setSelectValue("cpu", "2");
  setSelectValue("ram", "4");

  // Family change = re-compare (persist selection)
  ["awsFamily", "azFamily"].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener("change", () => compare(false));
  });

  // Tooltips
  initStorageTypeTooltip();
  initOsTypeTooltip();

  // Try enhancing meta from prices.json
  try {
    const r = await fetch(API_BASE, { mode: "cors" });
    const j = r.ok ? await r.json() : {};
    const meta = j.meta;

    if (j.storage?.aws || j.storage?.azure) {
      STORAGE_CFG = {
        aws: {
          region: j.storage?.aws?.region ?? STORAGE_CFG.aws.region,
          ssd_per_gb_month: Number(j.storage?.aws?.ssd_per_gb_month ?? STORAGE_CFG.aws.ssd_per_gb_month),
          hdd_st1_per_gb_month: Number(j.storage?.aws?.hdd_st1_per_gb_month ?? STORAGE_CFG.aws.hdd_st1_per_gb_month),
        },
        azure: {
          region: j.storage?.azure?.region ?? STORAGE_CFG.azure.region,
          ssd_monthly: j.storage?.azure?.ssd_monthly ?? STORAGE_CFG.azure.ssd_monthly,
          hdd_monthly: j.storage?.azure?.hdd_monthly ?? STORAGE_CFG.azure.hdd_monthly,
        }
      };
    }

    if (meta) {
      const osItems = Array.isArray(meta.os)
        ? meta.os.map(x => (typeof x === "string" ? { value: x, text: x } : { value: x.value, text: x.value }))
        : [{ value: "Linux", text: "Linux" }, { value: "Windows", text: "Windows" }];

      fillSelect("os",  osItems);
      fillSelect("cpu", (meta.vcpu || [1, 2, 4, 8, 16]).map(v => ({ value: v, text: v })));
      fillSelect("ram", (meta.ram  || [1, 2, 4, 8, 16, 32]).map(v => ({ value: v, text: v })));

      setSelectValue("os", "Linux");
      setSelectValue("cpu", "2");
      setSelectValue("ram", "4");
    }
  } catch {}

  // Initial compare
  compare(false);
});

// ============================================================
// Basic helpers
function fillSelect(id, items) {
  const el = document.getElementById(id);
  if (!el) return;
  el.innerHTML = "";
  for (const it of items) {
    const opt = document.createElement("option");
    opt.value = it.value;
    opt.textContent = it.text;
    el.appendChild(opt);
  }
}

function setSelectValue(id, value) {
  const el = document.getElementById(id);
  if (!el) return;
  const match = Array.from(el.options).find(o => o.value == value);
  if (match) el.value = value;
}

function fmt(n)      { return (n == null || isNaN(n)) ? "—" : `$${Number(n).toFixed(4)}`; }
function monthly(ph) { return (ph == null || isNaN(ph)) ? null : ph * HRS_PER_MONTH; }

function setStatus(msg, level="info") {
  const el = document.getElementById("status");
  if (!el) return;
  const err  = "var(--err,#b91c1c)";
  const warn = "var(--warn,#b45309)";
  const mut  = "var(--muted,#666)";
  el.textContent = msg;
  el.style.color = (level === "error") ? err :
                   (level === "warn")  ? warn : mut;
}

function safeSetText(id, text) {
  const el = document.getElementById(id);
  if (el) el.textContent = text;
}

function appendToText(id, extra) {
  const el = document.getElementById(id);
  if (el) el.textContent = (el.textContent || "") + extra;
}

function sumSafe(a, b) {
  const na = (a == null || isNaN(a)) ? 0 : Number(a);
  const nb = (b == null || isNaN(b)) ? 0 : Number(b);
  if (a == null && b == null) return null;
  return na + nb;
}

// ============================================================
// NORMALIZATION (On-Demand, Shared, OS)
function normalizeOs(val) {
  const s = String(val || '').toLowerCase();
  if (s.startsWith('win')) return 'windows';
  return 'linux';
}

function isOnDemandShared(x) {
  const bm  = String(x.billingModel || '').toLowerCase();  // expect "ondemand"
  const ten = String(x.tenancyType || '').toLowerCase();   // expect "shared"

  const okBilling = (!bm || bm === 'ondemand');
  const okTenancy = (!ten || ten === 'shared');

  const blob = [x.productName, x.skuName, x.meterName, x.instance]
    .filter(Boolean).join(" ").toLowerCase();

  const looksSpot = blob.includes("low priority") || blob.includes("spot")
                 || blob.includes("savings plan") || blob.includes("reserved");

  return okBilling && okTenancy && !looksSpot;
}

// ============================================================
// Family helpers
function showFamilyFilters() {
  const awsW = document.getElementById("awsFamilyWrap");
  const azW  = document.getElementById("azFamilyWrap");
  if (awsW) awsW.style.display = "flex";
  if (azW)  azW.style.display  = "flex";
}

function resetFamilyFilters() {
  const awsW = document.getElementById("awsFamilyWrap");
  const azW  = document.getElementById("azFamilyWrap");
  if (awsW) awsW.style.display = "none";
  if (azW)  azW.style.display  = "none";
}

function isAwsInFamily(inst, family) {
  if (!family) return true;
  const s = String(inst || "").toLowerCase();
  if (family === "general")  return /^[mt]/.test(s);
  if (family === "compute")  return /^c/.test(s);
  if (family === "memory")   return /^[rxz]/.test(s);
  return true;
}

function isAzureInFamily(inst, family) {
  if (!family) return true;
  const n = String(inst || "").toLowerCase();
  const m = n.match(/standard_([a-z]+)/);
  const first = m?.[1]?.[0] || n[0] || null;
  if (!first) return true;

  if (family === "general")  return first === "d" || first === "b";
  if (family === "compute")  return first === "f";
  if (family === "memory")   return first === "e" || first === "m";
  return true;
}

// ============================================================
// Compare
async function compare(resetFamilies = false) {
  const btn = document.getElementById("compareBtn");
  if (btn) btn.disabled = true;
  setStatus("Fetching local prices…");

  if (resetFamilies) {
    const awsSel = document.getElementById("awsFamily");
    const azSel  = document.getElementById("azFamily");
    if (awsSel) awsSel.value = "";
    if (azSel)  azSel.value  = "";
  }

  const os           = document.getElementById("os")?.value || "Linux";
  const vcpu         = Number(document.getElementById("cpu")?.value ?? 0);
  const ram          = Number(document.getElementById("ram")?.value ?? 0);
  const storageType  = (document.getElementById("storageType")?.value || "hdd").toLowerCase();
  const storageAmtGB = Number(document.getElementById("storageAmt")?.value ?? 0);

  const familyAws = document.getElementById("awsFamily")?.value || "";
  const familyAz  = document.getElementById("azFamily")?.value  || "";

  try {
    resetCards();

    const r = await fetch(API_BASE, { mode: "cors" });
    if (!r.ok) throw new Error(`Failed to read ${API_BASE}`);
    const data = await r.json();

    let awsCard;
    try {
      const a = findBestAws(data.aws || [], vcpu, ram, os, familyAws);
      awsCard = a ? {
        instance: a.instance,
        vcpu: a.vcpu,
        ram: a.ram,
        pricePerHourUSD: a.pricePerHourUSD,
        region: a.region
      } : null;
    } catch (e) {
      awsCard = { error: e.message || String(e) };
    }

    let azCard;
    try {
      const z = findBestAzure(data.azure || [], vcpu, ram, os, familyAz);
      azCard = z ? {
        instance: z.instance,
        vcpu: z.vcpu ?? vcpu,
        ram:  z.ram  ?? ram,
        pricePerHourUSD: z.pricePerHourUSD,
        region: z.region
      } : null;
    } catch (e) {
      azCard = { error: e.message || String(e) };
    }

    const selLabel = `${storageAmtGB} GB ${storageType.toUpperCase()}`;
    safeSetText("awsStorageSel", `Storage: ${selLabel}`);
    safeSetText("azStorageSel",  `Storage: ${selLabel}`);

    if (data.storage?.aws || data.storage?.azure) {
      STORAGE_CFG = {
        aws: {
          region: data.storage?.aws?.region ?? STORAGE_CFG.aws.region,
          ssd_per_gb_month: Number(data.storage?.aws?.ssd_per_gb_month ?? STORAGE_CFG.aws.ssd_per_gb_month),
          hdd_st1_per_gb_month: Number(data.storage?.aws?.hdd_st1_per_gb_month ?? STORAGE_CFG.aws.hdd_st1_per_gb_month),
        },
        azure: {
          region: data.storage?.azure?.region ?? STORAGE_CFG.azure.region,
          ssd_monthly: data.storage?.azure?.ssd_monthly ?? STORAGE_CFG.azure.ssd_monthly,
          hdd_monthly: data.storage?.azure?.hdd_monthly ?? STORAGE_CFG.azure.hdd_monthly,
        }
      };
    }

    const awsStorageMonthly = getAwsStorageMonthlyFromCfg(storageType, storageAmtGB, STORAGE_CFG.aws);
    const awsStorageHr      = (awsStorageMonthly != null) ? awsStorageMonthly / HRS_PER_MONTH : null;

    const { sku: azDiskSku, size: azDiskGB, monthlyUSD: azStorageMonthly } =
      getAzureStorageSkuAndMonthlyFromCfg(storageType, storageAmtGB, STORAGE_CFG.azure);
    const azStorageHr = (azStorageMonthly != null) ? azStorageMonthly / HRS_PER_MONTH : null;

    if (!awsCard || awsCard.error) {
      document.getElementById("awsInstance").innerHTML =
        `<strong>Recommended Instance:</strong> Error: ${awsCard?.error ?? "No match"}`;
    } else {
      document.getElementById("awsInstance").innerHTML =
        `<strong>Recommended Instance:</strong> ${awsCard.instance} (${awsCard.region})`;
      safeSetText("awsCpu",     `vCPU: ${awsCard.vcpu}`);
      safeSetText("awsRam",     `RAM: ${awsCard.ram} GB`);
      safeSetText("awsPrice",   `Price/hr: ${fmt(awsCard.pricePerHourUSD)}`);
      safeSetText("awsMonthly", `≈ Monthly: ${fmt(monthly(awsCard.pricePerHourUSD))}`);
    }

    if (!azCard || azCard.error) {
      document.getElementById("azInstance").innerHTML =
        `<strong>Recommended VM Size:</strong> Error: ${azCard?.error ?? "No match"}`;
    } else {
      document.getElementById("azInstance").innerHTML =
        `<strong>Recommended VM Size:</strong> ${azCard.instance} (${azCard.region})`;
      safeSetText("azCpu",     `vCPU: ${azCard.vcpu}`);
      safeSetText("azRam",     `RAM: ${azCard.ram} GB`);
      safeSetText("azPrice",   `Price/hr: ${fmt(azCard.pricePerHourUSD)}`);
      safeSetText("azMonthly", `≈ Monthly: ${fmt(monthly(azCard.pricePerHourUSD))}`);
    }

    safeSetText("awsStoragePriceHr", fmt(awsStorageHr));
    safeSetText("awsStorageMonthly", fmt(awsStorageMonthly));
    safeSetText("azStoragePriceHr",  fmt(azStorageHr));
    safeSetText("azStorageMonthly",  fmt(azStorageMonthly));

    if (azDiskSku) {
      const extra = (azDiskGB && azDiskGB !== storageAmtGB)
        ? ` (billed as ${azDiskGB} GB ${storageType.toUpperCase()}, ${azDiskSku})`
        : ` (${azDiskSku})`;
      appendToText("azStorageSel", extra);
    }

    const awsComputeHr     = awsCard?.pricePerHourUSD ?? null;
    const awsComputeMonth  = monthly(awsComputeHr);
    const awsTotalHr       = sumSafe(awsComputeHr, awsStorageHr);
    const awsTotalMonthly  = sumSafe(awsComputeMonth, awsStorageMonthly);
    safeSetText("awsTotalHr",      fmt(awsTotalHr));
    safeSetText("awsTotalMonthly", fmt(awsTotalMonthly));

    const azComputeHr     = azCard?.pricePerHourUSD ?? null;
    const azComputeMonth  = monthly(azComputeHr);
    const azTotalHr       = sumSafe(azComputeHr, azStorageHr);
    const azTotalMonthly  = sumSafe(azComputeMonth, azStorageMonthly);
    safeSetText("azTotalHr",      fmt(azTotalHr));
    safeSetText("azTotalMonthly", fmt(azTotalMonthly));

    showFamilyFilters();
    setStatus("Comparison complete ✓");
  } catch (err) {
    console.error(err);
    setStatus(`Error: ${err.message}`, "error");
    alert("Unable to read local prices. Please try again.");
  } finally {
    if (btn) btn.disabled = false;
  }
}

// ============================================================
// Tooltips (Storage & OS)

// Storage Type tooltip (non-blocking bubble)
function initStorageTypeTooltip() {
  const btn = document.getElementById("storageInfoBtn");
  const tip = document.getElementById("storageInfoTip");
  const label = document.querySelector('label[for="storageType"].label-with-info');
  const select = document.getElementById("storageType");
  if (!btn || !tip || !label || !select) return;

  function positionTip() {
    const rect = select.getBoundingClientRect();
    const scrollX = window.scrollX || window.pageXOffset;
    const scrollY = window.scrollY || window.pageYOffset;
    const left = rect.left + scrollX;
    const top  = rect.bottom + scrollY + 6;
    tip.style.position = "absolute";
    tip.style.left = `${left}px`;
    tip.style.top  = `${top}px`;
    const arrow = tip.querySelector(".info-pop__arrow");
    if (arrow) {
      const btnRect = btn.getBoundingClientRect();
      const offset = Math.max(10, Math.min(28, btnRect.left - rect.left));
      arrow.style.left = `${offset}px`;
    }
  }

  function openTip() {
    positionTip();
    tip.setAttribute("aria-hidden", "false");
    btn.setAttribute("aria-expanded", "true");
    document.addEventListener("click", outsideClose, { capture: true });
    document.addEventListener("keydown", escClose);
  }

  function closeTip() {
    tip.setAttribute("aria-hidden", "true");
    btn.setAttribute("aria-expanded", "false");
    document.removeEventListener("click", outsideClose, { capture: true });
    document.removeEventListener("keydown", escClose);
  }

  function toggleTip() {
    const open = tip.getAttribute("aria-hidden") === "false";
    open ? closeTip() : openTip();
  }

  function outsideClose(e) {
    if (tip.contains(e.target) || btn.contains(e.target) || label.contains(e.target) || select.contains(e.target)) return;
    closeTip();
  }
  function escClose(e) { if (e.key === "Escape") closeTip(); }

  btn.addEventListener("click", (e) => { e.stopPropagation(); toggleTip(); });
  btn.addEventListener("keydown", (e) => {
    if (e.key === "Enter" || e.key === " ") { e.preventDefault(); toggleTip(); }
  });

  window.addEventListener("resize", () => {
    if (tip.getAttribute("aria-hidden") === "false") positionTip();
  });
  window.addEventListener("scroll", () => {
    if (tip.getAttribute("aria-hidden") === "false") positionTip();
  });
}

// OS Type tooltip (non-blocking bubble)
function initOsTypeTooltip() {
  const btn    = document.getElementById("osInfoBtn");
  const tip    = document.getElementById("osInfoTip");
  let label    = document.querySelector('label[for="os"].label-with-info')
              || document.querySelector('label[for="os"]');
  const select = document.getElementById("os");
  if (!btn || !tip || !label || !select) {
    console.warn("[initOsTypeTooltip] Missing elements:",
      { btn: !!btn, tip: !!tip, label: !!label, select: !!select });
    return;
  }

  function getAnchorRect() { return (label || select).getBoundingClientRect(); }

  function positionTip() {
    const rect   = getAnchorRect();
    const scrollX = window.scrollX || window.pageXOffset;
    const scrollY = window.scrollY || window.pageYOffset;
    const left = rect.left + scrollX;
    const top  = rect.bottom + scrollY + 6;
    tip.style.position = "absolute";
    tip.style.left = `${left}px`;
    tip.style.top  = `${top}px`;
    const arrow = tip.querySelector(".info-pop__arrow");
    if (arrow) {
      const btnRect = btn.getBoundingClientRect();
      const offset = Math.max(10, Math.min(28, btnRect.left - rect.left));
      arrow.style.left = `${offset}px`;
    }
  }

  function openTip() {
    positionTip();
    tip.setAttribute("aria-hidden", "false");
    btn.setAttribute("aria-expanded", "true");
    document.addEventListener("click", outsideClose, { capture: true });
    document.addEventListener("keydown", escClose);
  }
  function closeTip() {
    tip.setAttribute("aria-hidden", "true");
    btn.setAttribute("aria-expanded", "false");
    document.removeEventListener("click", outsideClose, { capture: true });
    document.removeEventListener("keydown", escClose);
  }
  function toggleTip() {
    const open = tip.getAttribute("aria-hidden") === "false";
    open ? closeTip() : openTip();
  }
  function outsideClose(e) {
    if (tip.contains(e.target) || btn.contains(e.target) || label.contains(e.target) || select.contains(e.target)) return;
    closeTip();
  }
  function escClose(e) { if (e.key === "Escape") closeTip(); }

  btn.addEventListener("click", (e) => { e.stopPropagation(); toggleTip(); });
  btn.addEventListener("keydown", (e) => {
    if (e.key === "Enter" || e.key === " ") { e.preventDefault(); toggleTip(); }
  });

  window.addEventListener("resize", () => {
    if (tip.getAttribute("aria-hidden") === "false") positionTip();
  });
  window.addEventListener("scroll", () => {
    if (tip.getAttribute("aria-hidden") === "false") positionTip();
  });
}

// ============================================================
// Storage resolvers (from STORAGE_CFG)

// AWS: per-GB-month → monthly
function getAwsStorageMonthlyFromCfg(type, gb, awsCfg) {
  if (!isFinite(gb) || gb <= 0) return null;
  const t = (type || "hdd").toLowerCase();
  if (t === "ssd") return gb * Number(awsCfg?.ssd_per_gb_month ?? 0.08);
  return gb * Number(awsCfg?.hdd_st1_per_gb_month ?? 0.045);
}

// Azure: map (type, gb) → SKU & monthly price (rounded up to nearest supported size)
function getAzureStorageSkuAndMonthlyFromCfg(type, gb, azCfg) {
  const t = (type || "hdd").toLowerCase();
  if (!isFinite(gb) || gb <= 0) return { sku: null, size: null, monthlyUSD: null };

  const ssdTbl = azCfg?.ssd_monthly || {};
  const hddTbl = azCfg?.hdd_monthly || {};

  if (t === "ssd") {
    const size = nearestCeil(gb, Object.keys(ssdTbl).map(Number));
    const monthlyUSD = size != null ? (ssdTbl[size] ?? null) : null;
    const sku = sizeToAzureSku("ssd", size);
    return { sku, size, monthlyUSD };
  } else {
    const size = nearestCeil(gb, Object.keys(hddTbl).map(Number));
    const monthlyUSD = size != null ? (hddTbl[size] ?? null) : null;
    const sku = sizeToAzureSku("hdd", size);
    return { sku, size, monthlyUSD };
  }
}

function nearestCeil(requested, allowedSizes) {
  const sorted = [...allowedSizes].sort((a,b) => a - b);
  for (const s of sorted) if (requested <= s) return s;
  return sorted.length ? sorted[sorted.length - 1] : null;
}

function sizeToAzureSku(type, size) {
  if (!isFinite(size)) return null;
  if (type === "ssd") {
    // E1=4, E2=8, E3=16, E4=32, E6=64, E10=128, E15=256, E20=512
    const map = {4:"E1",8:"E2",16:"E3",32:"E4",64:"E6",128:"E10",256:"E15",512:"E20"};
    return map[size] || null;
  } else {
    // S4=32, S6=64, S10=128, S15=256, S20=512
    const map = {32:"S4",64:"S6",128:"S10",256:"S15",512:"S20"};
    return map[size] || null;
  }
}

// ============================================================
// Reset cards
function resetCards() {
  document.getElementById("awsInstance").innerHTML = `<strong>Recommended Instance:</strong> …`;
  document.getElementById("azInstance").innerHTML  = `<strong>Recommended VM Size:</strong> …`;

  safeSetText("awsCpu",      "vCPU: …");
  safeSetText("awsRam",      "RAM: …");
  safeSetText("awsPrice",    "Price/hr: -");
  safeSetText("awsMonthly",  "≈ Monthly: -");

  safeSetText("azCpu",       "vCPU: …");
  safeSetText("azRam",       "RAM: …");
  safeSetText("azPrice",     "Price/hr: -");
  safeSetText("azMonthly",   "≈ Monthly: -");

  safeSetText("awsStorageSel",      "Storage: —");
  safeSetText("awsStoragePriceHr",  "—");
  safeSetText("awsStorageMonthly",  "—");
  safeSetText("awsTotalHr",         "—");
  safeSetText("awsTotalMonthly",    "—");

  safeSetText("azStorageSel",       "Storage: —");
  safeSetText("azStoragePriceHr",   "—");
  safeSetText("azStorageMonthly",   "—");
  safeSetText("azTotalHr",          "—");
  safeSetText("azTotalMonthly",     "—");
}

// ============================================================
// Compute matching (apple-to-apple)
function findBestAws(list, vcpu, ram, os, family) {
  if (!Array.isArray(list) || list.length === 0)
    throw new Error("AWS price list is empty");

  const wantOS = String(os || "").toLowerCase();

  const filtered = list.filter(x =>
    isOnDemandShared(x) &&
    isFinite(x.vcpu) &&
    isFinite(x.ram) &&
    isFinite(x.pricePerHourUSD) &&
    (!wantOS || normalizeOs(x.os) === wantOS) &&
    isAwsInFamily(x.instance, family)
  );

  if (filtered.length === 0) {
    const fLabel = family ? ` family=${family}` : "";
    throw new Error(`No AWS entries for OS=${os || "any"}${fLabel}`);
  }

  let best = null;
  let bestScore = Infinity;
  for (const x of filtered) {
    const score = distance(x.vcpu, vcpu) + distance(x.ram, ram);
    const tieBreaker = x.pricePerHourUSD;
    if (score < bestScore || (score === bestScore && tieBreaker < (best?.pricePerHourUSD ?? Infinity))) {
      best = x;
      bestScore = score;
    }
  }
  return best;
}

function findBestAzure(list, vcpu, ram, os, family) {
  if (!Array.isArray(list) || list.length === 0)
    throw new Error("Azure price list is empty");

  const wantOS = String(os || "").toLowerCase();

  let pre = list.filter(x =>
    isOnDemandShared(x) &&
    (!wantOS || normalizeOs(x.os) === wantOS) &&
    isAzureInFamily(x.instance, family)
  );

  if (pre.length === 0) {
    pre = list.filter(x =>
      isOnDemandShared(x) &&
      isAzureInFamily(x.instance, family)
    );
  }

  if (pre.length === 0) {
    const fLabel = family ? ` family=${family}` : "";
    throw new Error(`No Azure entries for OS=${os || "any"}${fLabel}`);
  }

  const enriched = pre.map(x => {
    const meta = inferAzureCoresRamFromName(x.instance);
    return {
      ...x,
      vcpu: x.vcpu ?? meta.vcpu,
      ram:  x.ram  ?? meta.ram
    };
  });

  let best = null;
  let bestScore = Infinity;

  for (const x of enriched) {
    let score;
    if (isFinite(x.vcpu) && isFinite(x.ram)) {
      score = distance(x.vcpu, vcpu) + distance(x.ram, ram);
    } else {
      const price = x.pricePerHourUSD ?? Infinity;
      score = 500 + price; // prefer known-spec SKUs
    }
    const tieBreaker = x.pricePerHourUSD ?? Infinity;

    if (score < bestScore || (score === bestScore && tieBreaker < (best?.pricePerHourUSD ?? Infinity))) {
      best = x;
      bestScore = score;
    }
  }

  return best;
}

function distance(a, b) {
  if (!isFinite(a) || !isFinite(b)) return 1000;
  return Math.abs(Number(a) - Number(b));
}

// Try to parse cores/RAM from common Azure SKU patterns (best-effort)
function inferAzureCoresRamFromName(name) {
  if (!name || typeof name !== "string") return { vcpu: null, ram: null };
  const n = name.toLowerCase();
  const coreMatch = n.match(/(?:^standard_)?[a-z]+(\d+)[a-z]*/i);
  const vcpu = coreMatch ? Number(coreMatch[1]) : null;

  let familyRamPerCore = null;
  if (n.startsWith("standard_d")) familyRamPerCore = 4;
  else if (n.startsWith("standard_f")) familyRamPerCore = 2;
  else if (n.startsWith("standard_e")) familyRamPerCore = 8;
  else if (n.startsWith("standard_b")) familyRamPerCore = 4;
  else if (n.startsWith("standard_m")) familyRamPerCore = 16;

  const ram = (vcpu && familyRamPerCore) ? vcpu * familyRamPerCore : null;
  return { vcpu, ram };
}
